外观模式     ---对子系统提供统一的接口，单向，所有请求都委托子系统完成，树型 

定义
要求一个子系统的外部与内部的通信必须通过一个统一的对象进行，外观模式提供一个高层次的接口，使得子系统更易于使用。 
(其实就是封装，用于解决类与类间的依赖关系，比如本来是： 玩家依赖于：Q，A，E，R等键位对象，现在变成只依赖与脚本对象从而降低了类间的耦合度。)


本案例：
瑞雯和盲僧，打出组合键对应技能： 
瑞雯的光速QA，瞎子一秒七脚



两个角色
	1、Facade：外观角色，客户端可以调用他的方法，在外观角色中可以知道相关子系统的功能和责任；在正常情况下，
	它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。
	
	2、Subsystem：子系统角色，实现子系统的功能，处理外观类指派的任务，注意子系统类不含有外观类的引用
	
	
使用场景
	1、为访问一系列复杂的子系统提供一个简单的入口
	
	2、客户端程序与多个子系统间存在很大的依赖性，可以引入外观模式帮助解耦
	
	3、在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层间不直接产生联系，而通过外观类进行关联，降低层间的耦合度。
	

优缺点
优点：
	1、降低客户端与子系统间的耦合度；
	
	2、对客户屏蔽子系统组件，从而能简化接口，减少客户端处理的对象数目；
	
	3、一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象

缺点：
	1、在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了”开闭原则”。
	
	2、不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
	